---
import './PetCardSlider.scss';
import { getImageUrl } from '../../lib/utils/image';
import { formatDate } from '../../lib/utils/date';
import MaleIcon from '../../assets/icons/icon_male.svg?raw';
import FemaleIcon from '../../assets/icons/icon_female.svg?raw';
import SectionHeading from '../ui/SectionHeading.astro';

interface Pet {
  id: string;
  animalType: string;
  breedTypeJa: string;
  breedTypeEn: string;
  classification: string;
  gender: string;
  color: string;
  birthday: string;
  storeName: string;
  imageUrl01: string;
  isNew: string;
}

interface Props {
  pets: Pet[];
  title: string;
  subtitle?: string;
  titleDecorated?: boolean;
  sliderId: string;
  autoSlideInterval?: number;
}

const { 
  pets, 
  title, 
  subtitle = '',
  titleDecorated = true, 
  sliderId, 
  autoSlideInterval = 4000 
} = Astro.props;
---

<section class="pet-slider-section">
  <div class="container">
    <div data-aos="fade-up" data-aos-duration="1000" data-aos-easing="ease-out-cubic" data-aos-delay="600">
      {subtitle ? (
        <SectionHeading 
          subtitle={subtitle}
          title={title}
          size="large"
          alignment="center"
          subtitleClass="text-new"
          titleClass="text-new"
        />
      ) : titleDecorated ? (
        <h2 class="pet-slider-title">
          <span class="pet-slider-title__decoration">＼</span>
          {title}
          <span class="pet-slider-title__decoration">／</span>
        </h2>
      ) : (
        <h2 class="pet-slider-title">{title}</h2>
      )}
    </div>
    <div class="slider-container" data-slider-id={sliderId} data-auto-slide-interval={autoSlideInterval} data-aos="fade-up" data-aos-duration="1200" data-aos-delay="800" data-aos-easing="ease-out-cubic">
      <button class="slider-button prev" aria-label="前の画像へ">
        <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" width="24" height="24">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7" />
        </svg>
      </button>
      <div class="slider-track">
        <div class="pets-slider">
          {pets.map((pet) => {
            const placeholderImage = '/images/ui/img_loading-pet-image-01.webp';
            const imageUrl = pet.imageUrl01 ? getImageUrl(pet.imageUrl01, 600, 600) : placeholderImage;
            const formattedDate = formatDate(pet.birthday);
            const detailUrl = `/search/${pet.animalType}s/${pet.classification === 'mix' ? 'mix/' : ''}${pet.breedTypeEn.toLowerCase()}/${pet.id}`;
            
            return (
              <div class="pet-card__new">
                {pet.isNew === 'true' && <span class="pet-card__new-badge">NEW</span>}
                <a href={detailUrl} class="pet-card__new-link">
                  <div class="pet-card__new-inner">
                  <div class="pet-card__new-image-container">
                    <img
                      class="pet-card__new-image"
                      src={imageUrl}
                      alt={`${pet.breedTypeJa}の写真`}
                      loading="eager"
                      width="600"
                      height="600"
                      onload="this.parentElement.classList.add('loaded')"
                      onerror="this.src='/images/ui/img_loading-pet-image-01.webp'; this.parentElement.classList.add('loaded')"
                    />
                  </div>
                  <div class="pet-card__new-info">
                    <h3 class="pet-card__new-title">
                      {pet.breedTypeJa}
                      {pet.gender === '男の子' && (
                        <span 
                          class="pet-card__new-gender male" 
                          set:html={MaleIcon}
                        />
                      )}
                      {pet.gender === '女の子' && (
                        <span 
                          class="pet-card__new-gender female" 
                          set:html={FemaleIcon}
                        />
                      )}
                    </h3>
                    <div class="pet-card__new-details">
                      <p class="pet-card__new-detail-item">カラー：{pet.color}</p>
                      <p class="pet-card__new-detail-item">誕生日：{formattedDate}</p>
                      <p class="pet-card__new-detail-item">店舗：{pet.storeName}</p>
                    </div>
                  </div>
                  </div>
                </a>
              </div>
            );
          })}
        </div>
      </div>
      <button class="slider-button next" aria-label="次の画像へ">
        <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" width="24" height="24">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7" />
        </svg>
      </button>
      
      <!-- スライダードットナビゲーション -->
      <div class="slider-dots">
        {pets.map((_, i) => (
          <button class="slider-dot" data-slide={i} aria-label={`スライド${i + 1}へ`}></button>
        ))}
      </div>
    </div>
  </div>
</section>

<script>
  // スライダー処理関数
  function initializeSlider(container: HTMLElement) {
    const sliderId = container.dataset.sliderId;
    const autoSlideInterval = parseInt(container.dataset.autoSlideInterval || '4000', 10);
    
    const sliderTrack = container.querySelector('.slider-track') as HTMLElement;
    const prevButton = container.querySelector('.slider-button.prev') as HTMLButtonElement;
    const nextButton = container.querySelector('.slider-button.next') as HTMLButtonElement;
    const dots = container.querySelectorAll('.slider-dot') as NodeListOf<HTMLButtonElement>;
    
    if (!sliderTrack || !prevButton || !nextButton) {
      return null;
    }
    
    const sliderElement = sliderTrack.querySelector('.pets-slider') as HTMLElement;
    if (!sliderElement) {
      return null;
    }
    
    let currentSlide = 0;
    const petCards = sliderElement.querySelectorAll('.pet-card__new');
    if (!petCards.length) {
      prevButton.style.display = 'none';
      nextButton.style.display = 'none';
      return null;
    }
    
    // 画面サイズに応じたスライド表示列数を取得
    function getColumnsPerView() {
      // 1024px未満は2列、以上は3列（SCSSのブレイクポイントと一致）
      return window.innerWidth >= 1024 ? 3 : 2;
    }
    
    // ドットの状態を更新
    function updateDots() {
      dots.forEach((dot, index) => {
        if (index === currentSlide) {
          dot.classList.add('active');
        } else {
          dot.classList.remove('active');
        }
      });
    }
    
    // スライド位置の更新
    function updateSlidePosition() {
      // 現在の表示可能な列数
      const columnsPerView = getColumnsPerView();
      
      // カードの幅を取得（実際の要素から取得して正確に）
      const cardWidth = petCards[0].getBoundingClientRect().width;
      
      // CSSから計算済みのギャップ幅を取得する
      const computedStyle = window.getComputedStyle(sliderElement);
      const gapWidth = parseInt(computedStyle.gap || computedStyle.columnGap || '0', 10);
      
      // 移動量を計算（現在のスライド位置 × (カード幅 + ギャップ)）
      const offset = currentSlide * (cardWidth + gapWidth);
      sliderElement.style.transform = `translateX(-${offset}px)`;
      
      // 最大スライド数を計算
      const maxSlide = Math.max(0, petCards.length - columnsPerView);
      
      // スライダーボタンの表示/非表示を設定
      if (petCards.length <= columnsPerView) {
        // カードが表示エリアに収まる場合はボタンを非表示
        prevButton.style.display = 'none';
        nextButton.style.display = 'none';
      } else {
        // 収まらない場合はボタン表示
        prevButton.style.display = '';
        nextButton.style.display = '';
        
        // ボタンの有効/無効状態を更新
        prevButton.disabled = currentSlide === 0;
        nextButton.disabled = currentSlide >= maxSlide;
      }
      
      // ドットの状態を更新
      updateDots();
    }
    
    // 自動スライド機能
    function autoSlide() {
      const columnsPerView = getColumnsPerView();
      const maxSlide = Math.max(0, petCards.length - columnsPerView);
      
      if (maxSlide <= 0) return; // スライドが必要ない場合はスキップ
      
      if (currentSlide < maxSlide) {
        currentSlide++;
      } else {
        currentSlide = 0;
      }
      
      updateSlidePosition();
    }
    
    // 設定した間隔で自動スライド
    let interval = setInterval(autoSlide, autoSlideInterval);
    
    // 各ボタンのイベントリスナー設定
    prevButton.addEventListener('click', () => {
      if (currentSlide > 0) {
        currentSlide--;
        updateSlidePosition();
      }
    });
    
    nextButton.addEventListener('click', () => {
      const columnsPerView = getColumnsPerView();
      const maxSlide = Math.max(0, petCards.length - columnsPerView);
      
      if (currentSlide < maxSlide) {
        currentSlide++;
        updateSlidePosition();
      }
    });
    
    // ドットナビゲーションのイベント
    dots.forEach((dot, index) => {
      dot.addEventListener('click', () => {
        currentSlide = index;
        updateSlidePosition();
      });
    });

    // スワイプ機能を追加
    let startX = 0;
    let startY = 0;
    let isSwipeScrolling = false;
    
    sliderTrack.addEventListener('touchstart', (e) => {
      const touch = e.touches[0];
      startX = touch.clientX;
      startY = touch.clientY;
      isSwipeScrolling = false;
      clearInterval(interval); // スワイプ開始時は自動スライドを停止
    }, { passive: true });
    
    sliderTrack.addEventListener('touchmove', (e) => {
      if (isSwipeScrolling) return;
      
      const touch = e.touches[0];
      const deltaX = Math.abs(touch.clientX - startX);
      const deltaY = Math.abs(touch.clientY - startY);
      
      // 縦スクロールの判定：縦の移動量が横より大きい場合は縦スクロール
      if (deltaY > deltaX && deltaY > 10) {
        isSwipeScrolling = true;
        return;
      }
      
      // 横スワイプの場合はデフォルト動作を阻止
      if (deltaX > 10) {
        e.preventDefault();
      }
    }, { passive: false });
    
    sliderTrack.addEventListener('touchend', (e) => {
      if (isSwipeScrolling) {
        // 縦スクロールの場合は自動スライドを再開して終了
        interval = setInterval(autoSlide, autoSlideInterval);
        return;
      }
      
      const touch = e.changedTouches[0];
      const deltaX = touch.clientX - startX;
      const deltaY = Math.abs(touch.clientY - startY);
      
      // スワイプの最小距離（50px）と縦移動の最大許容値（30px）を設定
      if (Math.abs(deltaX) > 50 && deltaY < 30) {
        const columnsPerView = getColumnsPerView();
        const maxSlide = Math.max(0, petCards.length - columnsPerView);
        
        if (deltaX > 0 && currentSlide > 0) {
          // 右スワイプ（前のスライドへ）
          currentSlide--;
          updateSlidePosition();
        } else if (deltaX < 0 && currentSlide < maxSlide) {
          // 左スワイプ（次のスライドへ）
          currentSlide++;
          updateSlidePosition();
        }
      }
      
      // 自動スライドを再開
      interval = setInterval(autoSlide, autoSlideInterval);
    }, { passive: true });

    // マウスドラッグでのスワイプ機能を追加（デスクトップ対応）
    let isMouseDown = false;
    let mouseStartX = 0;
    
    sliderTrack.addEventListener('mousedown', (e) => {
      isMouseDown = true;
      mouseStartX = e.clientX;
      clearInterval(interval); // ドラッグ開始時は自動スライドを停止
      sliderTrack.style.cursor = 'grabbing';
      e.preventDefault(); // テキスト選択を防止
    });
    
    sliderTrack.addEventListener('mousemove', (e) => {
      if (!isMouseDown) return;
      e.preventDefault();
    });
    
    sliderTrack.addEventListener('mouseup', (e) => {
      if (!isMouseDown) return;
      
      isMouseDown = false;
      sliderTrack.style.cursor = 'grab';
      
      const deltaX = e.clientX - mouseStartX;
      
      // ドラッグの最小距離（30px）を設定
      if (Math.abs(deltaX) > 30) {
        const columnsPerView = getColumnsPerView();
        const maxSlide = Math.max(0, petCards.length - columnsPerView);
        
        if (deltaX > 0 && currentSlide > 0) {
          // 右ドラッグ（前のスライドへ）
          currentSlide--;
          updateSlidePosition();
        } else if (deltaX < 0 && currentSlide < maxSlide) {
          // 左ドラッグ（次のスライドへ）
          currentSlide++;
          updateSlidePosition();
        }
      }
      
      // 自動スライドを再開
      interval = setInterval(autoSlide, autoSlideInterval);
    });
    
    sliderTrack.addEventListener('mouseleave', () => {
      if (isMouseDown) {
        isMouseDown = false;
        sliderTrack.style.cursor = 'grab';
        // 自動スライドを再開
        interval = setInterval(autoSlide, autoSlideInterval);
      }
    });
    
    // スライダートラックにグラブカーソルを設定
    sliderTrack.style.cursor = 'grab';

    
    // カード幅はレイアウトクラスで設定するため、JSからの直接設定は不要
    
    // 画像読み込み後に正しい位置計算を行う
    const images = sliderElement.querySelectorAll('img');
    const imagePromises = Array.from(images).map(img => {
      // 画像コンテナに読み込み状態を表すクラスを追加
      const container = img.closest('.pet-card__new-image-container');
      
      if (img.complete) {
        if (container) container.classList.add('loaded');
        return Promise.resolve();
      }
      
      return new Promise(resolve => {
        img.onload = () => {
          if (container) container.classList.add('loaded');
          resolve();
        };
        img.onerror = resolve; // 画像が読み込めなくても続行
      });
    });
    
    // 画像読み込み完了後に位置計算を実行
    Promise.all(imagePromises).then(() => {
      updateSlidePosition();
    });
    
    // 必要な場合は更新前におおよその位置計算を行う
    updateSlidePosition();
    
    // ウィンドウリサイズ時の処理 - スロットリングを適用
    let resizeTimeout: number;
    window.addEventListener('resize', () => {
      // 連続したリサイズイベントで処理が重複しないようにスロットリング
      if (resizeTimeout) clearTimeout(resizeTimeout);
      
      resizeTimeout = setTimeout(() => {
        // リサイズ完了後に一度だけ実行
        const columnsPerView = getColumnsPerView();
        
        const maxSlide = Math.max(0, petCards.length - columnsPerView);
        
        // 現在位置が最大値を超えないように調整
        currentSlide = Math.min(currentSlide, maxSlide);
        
        // スライド位置を更新
        requestAnimationFrame(() => {
          updateSlidePosition();
        });
      }, 100); // 100ms間隔でスロットリング
    });
    
    // タブが非表示の時は自動スライドを停止してパフォーマンスを改善
    document.addEventListener('visibilitychange', () => {
      if (document.hidden) {
        clearInterval(interval);
      } else {
        interval = setInterval(autoSlide, autoSlideInterval);
      }
    });
    
    // クリーンアップ
    document.addEventListener('astro:before-swap', () => {
      clearInterval(interval);
    });
    
    return { updateSlidePosition };
  }
  
  // ページ読み込み完了時にすべてのスライダーを初期化
  document.addEventListener('DOMContentLoaded', () => {
    const sliderContainers = document.querySelectorAll('.slider-container');
    sliderContainers.forEach(container => {
      initializeSlider(container as HTMLElement);
    });
  });
</script>